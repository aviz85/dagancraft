<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Clone</title>
    <!-- טעינת Three.js באופן סינכרוני אך בטוח -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.149.0/three.min.js"></script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif;
        }
        canvas { 
            display: block; 
        }
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 10;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            z-index: 5;
            pointer-events: none;
        }
        #crosshair::before,
        #crosshair::after {
            content: "";
            position: absolute;
            background: white;
        }
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
            top: 0;
        }
        #crosshair::after {
            width: 20px;
            height: 2px;
            left: 0;
            top: 9px;
        }
        #time-display {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="instructions">
        WASD - Move<br>
        SPACE - Jump<br>
        SHIFT - Crawl<br>
        CLICK - Place/Remove Block<br>
        F - Toggle view (First/Third person)<br>
        ESC - Toggle mouse lock
    </div>
    <div id="crosshair"></div>
    <div id="time-display">00:00</div>

    <script>
        // PointerLockControls implementation inline
        class PointerLockControls {
            constructor(camera, domElement) {
                this.camera = camera;
                this.domElement = domElement || document.body;
                this.isLocked = false;
                
                // Initial camera rotation
                this.euler = new THREE.Euler(0, 0, 0, 'YXZ');
                this.vector = new THREE.Vector3();
                
                // Rotation state
                this.minPolarAngle = 0;
                this.maxPolarAngle = Math.PI;
                
                this.changeEvent = { type: 'change' };
                this.lockEvent = { type: 'lock' };
                this.unlockEvent = { type: 'unlock' };
                
                // Bind methods to this instance
                this.onMouseMove = this.onMouseMove.bind(this);
                this.onPointerlockChange = this.onPointerlockChange.bind(this);
                this.onPointerlockError = this.onPointerlockError.bind(this);
                
                this.connect();
            }
            
            connect() {
                this.domElement.ownerDocument.addEventListener('mousemove', this.onMouseMove);
                this.domElement.ownerDocument.addEventListener('pointerlockchange', this.onPointerlockChange);
                this.domElement.ownerDocument.addEventListener('pointerlockerror', this.onPointerlockError);
            }
            
            disconnect() {
                this.domElement.ownerDocument.removeEventListener('mousemove', this.onMouseMove);
                this.domElement.ownerDocument.removeEventListener('pointerlockchange', this.onPointerlockChange);
                this.domElement.ownerDocument.removeEventListener('pointerlockerror', this.onPointerlockError);
            }
            
            dispose() {
                this.disconnect();
            }
            
            getObject() {
                return this.camera;
            }
            
            getDirection() {
                const direction = new THREE.Vector3(0, 0, -1);
                const rotation = new THREE.Euler(0, 0, 0, 'YXZ');
                rotation.set(this.euler.x, this.euler.y, 0);
                direction.applyEuler(rotation);
                return direction;
            }
            
            moveForward(distance) {
                this.vector.setFromMatrixColumn(this.camera.matrix, 0);
                this.vector.crossVectors(this.camera.up, this.vector);
                this.camera.position.addScaledVector(this.vector, distance);
            }
            
            moveRight(distance) {
                this.vector.setFromMatrixColumn(this.camera.matrix, 0);
                this.camera.position.addScaledVector(this.vector, distance);
            }
            
            lock() {
                this.domElement.requestPointerLock();
            }
            
            unlock() {
                this.domElement.ownerDocument.exitPointerLock();
            }
            
            onMouseMove(event) {
                if (!this.isLocked) return;
                
                const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
                
                this.euler.y -= movementX * 0.002;
                this.euler.x -= movementY * 0.002;
                
                this.euler.x = Math.max(Math.PI / 2 - this.maxPolarAngle, Math.min(Math.PI / 2 - this.minPolarAngle, this.euler.x));
                
                this.camera.quaternion.setFromEuler(this.euler);
                
                this.dispatchEvent(this.changeEvent);
            }
            
            onPointerlockChange() {
                if (this.domElement.ownerDocument.pointerLockElement === this.domElement) {
                    this.dispatchEvent(this.lockEvent);
                    this.isLocked = true;
                } else {
                    this.dispatchEvent(this.unlockEvent);
                    this.isLocked = false;
                }
            }
            
            onPointerlockError() {
                console.error('PointerLockControls: Unable to use Pointer Lock API');
            }
            
            addEventListener(type, listener) {
                if (!this._listeners) this._listeners = {};
                if (!this._listeners[type]) this._listeners[type] = [];
                if (this._listeners[type].indexOf(listener) === -1) {
                    this._listeners[type].push(listener);
                }
            }
            
            removeEventListener(type, listener) {
                if (!this._listeners) return;
                if (!this._listeners[type]) return;
                const index = this._listeners[type].indexOf(listener);
                if (index !== -1) {
                    this._listeners[type].splice(index, 1);
                }
            }
            
            dispatchEvent(event) {
                if (!this._listeners) return;
                const listeners = this._listeners[event.type];
                if (listeners) {
                    for (let i = 0, l = listeners.length; i < l; i++) {
                        listeners[i].call(this, event);
                    }
                }
            }
        }
        
        // ביצוע המשחק כאשר ה-DOM נטען
        document.addEventListener('DOMContentLoaded', startGame);
        
        function startGame() {
            // Game state
            let gameTime = 0; // 0-24000, similar to Minecraft
            let isThirdPerson = false;
            
            // Scene setup
            const scene = new THREE.Scene();
            
            // Sky setup
            const skyRadius = 500;
            const skyGeometry = new THREE.SphereGeometry(skyRadius, 32, 32);
            // We're turning the sphere inside out by scaling it negatively
            skyGeometry.scale(-1, 1, 1);
            
            // Sky materials for day and night
            const daySkyMaterial = new THREE.MeshBasicMaterial({
                color: 0x87CEEB, // Sky blue
                side: THREE.BackSide
            });
            
            const nightSkyMaterial = new THREE.MeshBasicMaterial({
                color: 0x0a0a2a, // Dark blue
                side: THREE.BackSide
            });
            
            const sky = new THREE.Mesh(skyGeometry, daySkyMaterial);
            scene.add(sky);
            
            // Create stars
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({
                color: 0xFFFFFF,
                size: 1,
                sizeAttenuation: false,
                transparent: true
            });
            
            const starVertices = [];
            for (let i = 0; i < 1000; i++) {
                const x = Math.random() * 2 - 1;
                const y = Math.random() * 0.5 + 0.2; // mostly above horizon
                const z = Math.random() * 2 - 1;
                const normalizationFactor = 1 / Math.sqrt(x * x + y * y + z * z);
                
                starVertices.push(
                    x * normalizationFactor * skyRadius * 0.95, 
                    y * normalizationFactor * skyRadius * 0.95, 
                    z * normalizationFactor * skyRadius * 0.95
                );
            }
            
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const stars = new THREE.Points(starGeometry, starMaterial);
            stars.visible = false; // Initially not visible during day
            scene.add(stars);
            
            // Create Sun
            const sunGeometry = new THREE.SphereGeometry(20, 16, 16);
            const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffcc66 });
            const sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.position.set(0, 400, 0);
            scene.add(sun);
            
            // Create Moon
            const moonGeometry = new THREE.SphereGeometry(15, 16, 16);
            const moonMaterial = new THREE.MeshBasicMaterial({ color: 0xeeeeee });
            const moon = new THREE.Mesh(moonGeometry, moonMaterial);
            moon.position.set(0, -400, 0);
            scene.add(moon);
            
            // Create clouds
            const clouds = new THREE.Group();
            
            function createCloud(x, y, z, scale) {
                const cloudGroup = new THREE.Group();
                
                // Create multiple spheres to form a cloud
                const sphereGeom = new THREE.SphereGeometry(10, 8, 8);
                const cloudMat = new THREE.MeshLambertMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.8
                });
                
                // Create main cloud part
                const mainSphere = new THREE.Mesh(sphereGeom, cloudMat);
                cloudGroup.add(mainSphere);
                
                // Add more spheres to create a cloud-like shape
                for (let i = 0; i < 5; i++) {
                    const sphere = new THREE.Mesh(sphereGeom, cloudMat);
                    sphere.position.set(
                        Math.random() * 15 - 7.5,
                        Math.random() * 5 - 2.5,
                        Math.random() * 15 - 7.5
                    );
                    sphere.scale.set(
                        Math.random() * 0.5 + 0.5,
                        Math.random() * 0.3 + 0.5,
                        Math.random() * 0.5 + 0.5
                    );
                    cloudGroup.add(sphere);
                }
                
                cloudGroup.position.set(x, y, z);
                cloudGroup.scale.set(scale, scale / 2, scale);
                
                return cloudGroup;
            }
            
            // Create multiple clouds at random positions
            for (let i = 0; i < 15; i++) {
                const cloudSize = Math.random() * 1.5 + 1;
                const cloudX = Math.random() * 800 - 400;
                const cloudY = 80 + Math.random() * 40; // Keep clouds at roughly same height
                const cloudZ = Math.random() * 800 - 400;
                
                const cloud = createCloud(cloudX, cloudY, cloudZ, cloudSize);
                cloud.userData = {
                    speed: Math.random() * 0.05 + 0.05, // Each cloud has a unique speed
                    direction: new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize()
                };
                
                clouds.add(cloud);
            }
            
            scene.add(clouds);
            
            // Camera setup
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 2;
            
            // Renderer setup
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 200, 100);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            scene.add(directionalLight);
            
            // Player model
            const playerGroup = new THREE.Group();
            
            // Create head
            const headGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xF5DEB3 }); // Wheat color for skin
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.5;
            playerGroup.add(head);
            
            // Create body
            const bodyGeometry = new THREE.BoxGeometry(0.5, 0.7, 0.25);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x0000FF }); // Blue shirt
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.95;
            playerGroup.add(body);
            
            // Create arms
            const armGeometry = new THREE.BoxGeometry(0.15, 0.7, 0.25);
            const armMaterial = new THREE.MeshLambertMaterial({ color: 0x0000FF }); // Blue
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.325, 0.95, 0);
            playerGroup.add(rightArm);
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.325, 0.95, 0);
            playerGroup.add(leftArm);
            
            // Create legs
            const legGeometry = new THREE.BoxGeometry(0.2, 0.7, 0.25);
            const legMaterial = new THREE.MeshLambertMaterial({ color: 0x1E90FF }); // Blue pants
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.15, 0.35, 0);
            playerGroup.add(rightLeg);
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.15, 0.35, 0);
            playerGroup.add(leftLeg);
            
            // Make player model not visible in first-person
            playerGroup.visible = false;
            scene.add(playerGroup);
            
            // Controls setup - using our custom PointerLockControls implementation
            const controls = new PointerLockControls(camera, document.body);
            
            // Handle locking/unlocking controls
            document.addEventListener('click', () => {
                if (!controls.isLocked) {
                    controls.lock();
                }
            });
            
            controls.addEventListener('lock', () => {
                document.getElementById('instructions').style.display = 'none';
            });
            
            controls.addEventListener('unlock', () => {
                document.getElementById('instructions').style.display = 'block';
            });
            
            // Player physics
            const playerHeight = 1.8;
            let playerVelocity = new THREE.Vector3();
            let playerDirection = new THREE.Vector3();
            let playerOnGround = false;
            let isCrawling = false;
            const normalHeight = playerHeight;
            const crouchHeight = playerHeight * 0.5;
            
            // Movement controls
            const keys = {
                forward: false,
                backward: false,
                left: false,
                right: false,
                jump: false,
                crawl: false,
                viewToggle: false
            };
            
            document.addEventListener('keydown', (event) => {
                switch (event.code) {
                    case 'KeyW':
                        keys.forward = true;
                        break;
                    case 'KeyS':
                        keys.backward = true;
                        break;
                    case 'KeyA':
                        keys.left = true;
                        break;
                    case 'KeyD':
                        keys.right = true;
                        break;
                    case 'Space':
                        keys.jump = true;
                        break;
                    case 'ShiftLeft':
                        if (!keys.crawl) {
                            keys.crawl = true;
                            isCrawling = true;
                            // Lower view for crouching
                            if (isThirdPerson) {
                                camera.position.y = crouchHeight * 0.7;
                            } else {
                                camera.position.y = crouchHeight;
                            }
                        }
                        break;
                    case 'KeyF':
                        if (!keys.viewToggle) {
                            keys.viewToggle = true;
                            toggleView();
                        }
                        break;
                }
            });
            
            document.addEventListener('keyup', (event) => {
                switch (event.code) {
                    case 'KeyW':
                        keys.forward = false;
                        break;
                    case 'KeyS':
                        keys.backward = false;
                        break;
                    case 'KeyA':
                        keys.left = false;
                        break;
                    case 'KeyD':
                        keys.right = false;
                        break;
                    case 'Space':
                        keys.jump = false;
                        break;
                    case 'ShiftLeft':
                        keys.crawl = false;
                        isCrawling = false;
                        // Reset height after crouching
                        if (isThirdPerson) {
                            camera.position.y = normalHeight * 0.7;
                        } else {
                            camera.position.y = normalHeight;
                        }
                        break;
                    case 'KeyF':
                        keys.viewToggle = false;
                        break;
                }
            });
            
            // Toggle between first person and third person view
            function toggleView() {
                isThirdPerson = !isThirdPerson;
                
                if (isThirdPerson) {
                    // Position camera behind player
                    playerGroup.visible = true;
                    camera.position.z = 3; // Move back
                    camera.position.y = isCrawling ? crouchHeight * 0.7 : normalHeight * 0.7; // Higher for third person
                } else {
                    // Reset to first person
                    playerGroup.visible = false;
                    camera.position.z = 0;
                    camera.position.y = isCrawling ? crouchHeight : normalHeight;
                }
            }
            
            // Block materials - using solid colors instead of textures
            const grassMaterial = new THREE.MeshLambertMaterial({ color: 0x7cfc00 }); // Green
            const dirtMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 }); // Brown
            const stoneMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 }); // Gray
            
            // Block geometry
            const blockGeometry = new THREE.BoxGeometry(1, 1, 1);
            
            // World generation
            const worldSize = 20;
            const maxHeight = 4;
            const blocks = [];
            
            for (let x = -worldSize; x <= worldSize; x++) {
                for (let z = -worldSize; z <= worldSize; z++) {
                    // Simple height map
                    const height = Math.floor(Math.random() * 2) - 2;
                    
                    // Create ground blocks
                    for (let y = height; y >= -3; y--) {
                        let material;
                        if (y === height) {
                            material = grassMaterial;
                        } else if (y > height - 3) {
                            material = dirtMaterial;
                        } else {
                            material = stoneMaterial;
                        }
                        
                        const block = new THREE.Mesh(blockGeometry, material);
                        block.position.set(x, y, z);
                        block.castShadow = true;
                        block.receiveShadow = true;
                        scene.add(block);
                        blocks.push(block);
                    }
                }
            }
            
            // Raycaster for block interactions
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            
            // Collision detection helpers
            function checkBlockCollision(position, radius) {
                // Check if player collides with any block
                for (const block of blocks) {
                    const blockPos = block.position;
                    const blockHalfSize = 0.5; // Half size of a block
                    
                    // Check if player is colliding with this block in each axis
                    const collisionX = Math.abs(position.x - blockPos.x) < (radius + blockHalfSize);
                    const collisionY = Math.abs(position.y - blockPos.y) < (radius + blockHalfSize);
                    const collisionZ = Math.abs(position.z - blockPos.z) < (radius + blockHalfSize);
                    
                    // If colliding in all three axes, we have a collision
                    if (collisionX && collisionY && collisionZ) {
                        return block;
                    }
                }
                return null;
            }
            
            function isBlockBelow(position) {
                // Raycasting downward to detect ground
                const rayOrigin = new THREE.Vector3(position.x, position.y - 0.9, position.z);
                const rayDirection = new THREE.Vector3(0, -1, 0); // Downward direction
                
                // Create a ray
                raycaster.set(rayOrigin, rayDirection);
                
                // Check intersections with blocks
                const intersects = raycaster.intersectObjects(blocks);
                
                // If we hit something below us within a short distance, we're standing on ground
                if (intersects.length > 0 && intersects[0].distance < 0.5) {
                    return {
                        isOnGround: true,
                        block: intersects[0].object,
                        distance: intersects[0].distance
                    };
                }
                
                return {
                    isOnGround: false,
                    block: null,
                    distance: Infinity
                };
            }
            
            function checkBlockInDirection(position, direction, distance) {
                const rayOrigin = position.clone();
                const rayDirection = direction.clone().normalize();
                
                raycaster.set(rayOrigin, rayDirection);
                
                const intersects = raycaster.intersectObjects(blocks);
                
                if (intersects.length > 0 && intersects[0].distance < distance) {
                    return {
                        hasBlock: true,
                        block: intersects[0].object,
                        distance: intersects[0].distance,
                        normal: intersects[0].face.normal
                    };
                }
                
                return {
                    hasBlock: false,
                    block: null,
                    distance: Infinity,
                    normal: null
                };
            }
            
            function resolveBlockCollision(position, velocity, playerRadius) {
                // Check for collision in movement direction
                const movementDirection = new THREE.Vector3(velocity.x, 0, velocity.z).normalize();
                
                // Forward collision check
                if (movementDirection.length() > 0) {
                    const forwardCheck = checkBlockInDirection(
                        position.clone().add(new THREE.Vector3(0, -0.5, 0)), // Check from feet
                        movementDirection,
                        playerRadius + 0.1
                    );
                    
                    if (forwardCheck.hasBlock) {
                        // Attempt to step up if the block is only 1 block high
                        const aboveCheck = checkBlockInDirection(
                            position.clone().add(new THREE.Vector3(0, 0.5, 0)), // Check from head level
                            movementDirection,
                            playerRadius + 0.1
                        );
                        
                        if (!aboveCheck.hasBlock) {
                            // We can step up
                            if (playerOnGround && velocity.y <= 0) {
                                velocity.y = 0.3; // Small upward boost to step up
                            }
                        } else {
                            // Can't step up, stop horizontal movement
                            const stopDirection = new THREE.Vector3().copy(movementDirection);
                            velocity.x = 0;
                            velocity.z = 0;
                        }
                    }
                }
                
                // Attempt the movement
                position.x += velocity.x;
                position.z += velocity.z;
                
                return position;
            }
            
            // Block interaction (add/remove)
            window.addEventListener('mousedown', (event) => {
                if (!controls.isLocked) return;
                
                // Update raycaster
                raycaster.setFromCamera(new THREE.Vector2(), camera);
                
                // Check for intersections
                const intersects = raycaster.intersectObjects(blocks);
                
                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    
                    // Left click (remove block)
                    if (event.button === 0) {
                        scene.remove(intersect.object);
                        blocks.splice(blocks.indexOf(intersect.object), 1);
                    }
                    
                    // Right click (add block)
                    if (event.button === 2) {
                        // Calculate position for new block
                        const position = intersect.object.position.clone().add(intersect.face.normal);
                        
                        // Create new block
                        const block = new THREE.Mesh(blockGeometry, stoneMaterial);
                        block.position.copy(position);
                        block.castShadow = true;
                        block.receiveShadow = true;
                        scene.add(block);
                        blocks.push(block);
                    }
                }
            });
            
            // Prevent right-click context menu
            document.addEventListener('contextmenu', (event) => event.preventDefault());
            
            // Gravity and collision constants
            const gravity = 20; // Increased from 9.8 to make gravity feel stronger
            const jumpStrength = 8; // Increased to compensate for higher gravity
            
            // Game loop
            const clock = new THREE.Clock();
            
            function animate() {
                requestAnimationFrame(animate);
                
                const delta = Math.min(clock.getDelta(), 0.1);
                
                // Update game time (full day-night cycle in 10 minutes)
                gameTime += delta * 40; // 24000 / (10 * 60) = 40 time units per second
                if (gameTime >= 24000) gameTime = 0;
                
                // Convert game time to hours for display
                const hours = Math.floor((gameTime / 1000) % 24);
                const minutes = Math.floor((gameTime % 1000) / 1000 * 60);
                document.getElementById('time-display').textContent = 
                    `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                
                // Sky color based on time
                const isDay = gameTime >= 0 && gameTime < 12000;
                
                if (isDay) {
                    // Daytime - gradual transition from dawn to noon to dusk
                    let dayProgress;
                    
                    if (gameTime < 6000) {
                        // Dawn transition 0-6000
                        dayProgress = gameTime / 6000;
                        sky.material = daySkyMaterial;
                        sky.material.color.setHSL(0.6, 0.8, 0.3 + dayProgress * 0.5);
                    } else {
                        // Dusk transition 6000-12000
                        dayProgress = (12000 - gameTime) / 6000;
                        sky.material = daySkyMaterial;
                        sky.material.color.setHSL(0.6, 0.8, 0.3 + dayProgress * 0.5);
                    }
                    
                    // Hide stars during day
                    stars.visible = false;
                } else {
                    // Nighttime
                    sky.material = nightSkyMaterial;
                    
                    // Show stars at night
                    stars.visible = true;
                }
                
                // Update sun and moon positions
                const timeAngle = (gameTime / 24000) * Math.PI * 2;
                sun.position.x = Math.cos(timeAngle) * skyRadius * 0.8;
                sun.position.y = Math.sin(timeAngle) * skyRadius * 0.8;
                
                // Moon is opposite the sun
                moon.position.x = Math.cos(timeAngle + Math.PI) * skyRadius * 0.8;
                moon.position.y = Math.sin(timeAngle + Math.PI) * skyRadius * 0.8;
                
                // Update ambient light based on time
                if (isDay) {
                    // Day light
                    let lightIntensity;
                    if (gameTime < 6000) {
                        // Dawn transition
                        lightIntensity = 0.2 + (gameTime / 6000) * 0.6;
                    } else {
                        // Dusk transition
                        lightIntensity = 0.2 + ((12000 - gameTime) / 6000) * 0.6;
                    }
                    ambientLight.intensity = lightIntensity;
                    directionalLight.intensity = lightIntensity * 1.5;
                } else {
                    // Night light
                    ambientLight.intensity = 0.2;
                    directionalLight.intensity = 0.3;
                }
                
                // Move clouds
                clouds.children.forEach(cloud => {
                    cloud.position.x += cloud.userData.direction.x * cloud.userData.speed;
                    cloud.position.z += cloud.userData.direction.z * cloud.userData.speed;
                    
                    // Reset cloud position if it goes too far
                    if (Math.abs(cloud.position.x) > 500 || Math.abs(cloud.position.z) > 500) {
                        const newPos = new THREE.Vector3(
                            Math.random() * 800 - 400,
                            cloud.position.y,
                            Math.random() * 800 - 400
                        );
                        cloud.position.copy(newPos);
                    }
                    
                    // Slowly rotate cloud for a more dynamic look
                    cloud.rotation.y += 0.001;
                });
                
                // Handle physics and movement
                // Calculate velocity based on input
                playerDirection.z = Number(keys.forward) - Number(keys.backward);
                playerDirection.x = Number(keys.right) - Number(keys.left);
                playerDirection.normalize();
                
                // Current position
                const playerPosition = controls.getObject().position;
                
                // Check if standing on ground
                const groundCheck = isBlockBelow(playerPosition);
                playerOnGround = groundCheck.isOnGround;
                
                // Apply gravity only when not on ground
                if (!playerOnGround) {
                    playerVelocity.y -= gravity * delta;
                } else if (playerVelocity.y < 0) {
                    // Stop falling when on ground
                    playerVelocity.y = 0;
                }
                
                // Handle jumping - only if on ground
                if (keys.jump && playerOnGround) {
                    playerVelocity.y = jumpStrength;
                    playerOnGround = false;
                }
                
                // Set move speed based on crawling
                const currentMoveSpeed = isCrawling ? 2 : 5;
                
                // Movement velocity
                const moveVelocity = new THREE.Vector3(
                    playerDirection.x * currentMoveSpeed * delta,
                    playerVelocity.y * delta,
                    playerDirection.z * currentMoveSpeed * delta
                );
                
                // Player collision radius (slightly smaller than a block)
                const playerRadius = 0.3;
                
                // Handle block collisions
                resolveBlockCollision(playerPosition, moveVelocity, playerRadius);
                
                // Apply movement with collision resolution
                if (moveVelocity.x !== 0) controls.moveRight(moveVelocity.x);
                if (moveVelocity.z !== 0) controls.moveForward(moveVelocity.z);
                
                // Apply vertical velocity (falling/jumping)
                playerPosition.y += moveVelocity.y;
                
                // Crouching height adjustment
                const currentHeight = isCrawling ? crouchHeight : normalHeight;
                
                // Ensure we don't go below ground level if on ground
                if (playerOnGround && playerPosition.y < currentHeight) {
                    playerPosition.y = currentHeight;
                }
                
                // Extra safety to prevent falling through the world
                if (playerPosition.y < -10) {
                    // Teleport back up if player falls out of the world
                    playerPosition.y = 20;
                    playerVelocity.set(0, 0, 0);
                }
                
                // Check for head collisions (ceiling)
                const headCheck = checkBlockInDirection(
                    playerPosition.clone(),
                    new THREE.Vector3(0, 1, 0), // Upward
                    1.0 // Check 1 block above
                );
                
                if (headCheck.hasBlock) {
                    // Hit ceiling, stop upward movement
                    if (playerVelocity.y > 0) {
                        playerVelocity.y = 0;
                    }
                }
                
                // Update player model position to follow camera
                playerGroup.position.x = camera.position.x;
                playerGroup.position.z = camera.position.z;
                playerGroup.position.y = camera.position.y - (isThirdPerson ? 
                    (isCrawling ? crouchHeight * 0.7 : normalHeight * 0.7) : 
                    (isCrawling ? crouchHeight : normalHeight));
                
                // Make player model face the same direction as camera
                playerGroup.rotation.y = controls.getObject().rotation.y;
                
                // Animate player model
                if (playerDirection.z !== 0 || playerDirection.x !== 0) {
                    // Walking animation
                    const walkSpeed = 8;
                    const walkAmplitude = 0.2;
                    
                    const legSwing = Math.sin(gameTime * walkSpeed * delta) * walkAmplitude;
                    rightLeg.rotation.x = legSwing;
                    leftLeg.rotation.x = -legSwing;
                    
                    rightArm.rotation.x = -legSwing;
                    leftArm.rotation.x = legSwing;
                } else {
                    // Reset to standing position
                    rightLeg.rotation.x = 0;
                    leftLeg.rotation.x = 0;
                    rightArm.rotation.x = 0;
                    leftArm.rotation.x = 0;
                }
                
                // Render scene
                renderer.render(scene, camera);
            }
            
            // Handle window resizing
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Start animation loop
            animate();
        }
    </script>
</body>
</html> 